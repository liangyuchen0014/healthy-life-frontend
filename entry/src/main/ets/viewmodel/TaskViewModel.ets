/*
 * Copyright (c) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License,Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
æ‚¨å¥½ï¼Œè¿™æ˜¯Bingã€‚æˆ‘å¯ä»¥ç”¨ä¸­æ–‡å’Œæ‚¨äº¤æµã€‚ðŸ˜Š

è¿™æ®µä»£ç æ˜¯ç”¨TypeScriptç¼–å†™çš„ï¼ŒTypeScriptæ˜¯ä¸€ç§åŸºäºŽJavaScriptçš„å¼ºç±»åž‹ç¼–ç¨‹è¯­è¨€Â¹ã€‚è¿™ä¸ªå‡½æ•°çš„åŽŸç†æ˜¯ï¼š

- å®šä¹‰ä¸€ä¸ªåä¸ºgetAllTaskçš„å¼‚æ­¥å‡½æ•°ï¼Œå®ƒæ²¡æœ‰å‚æ•°ï¼Œè¿”å›žä¸€ä¸ªPromiseå¯¹è±¡ã€‚
- åœ¨Promiseå¯¹è±¡ä¸­ï¼Œå®šä¹‰ä¸€ä¸ªå›žè°ƒå‡½æ•°ï¼Œå®ƒæŽ¥å—ä¸€ä¸ªå‚æ•°resolveï¼Œè¡¨ç¤ºæˆåŠŸæ—¶çš„å¤„ç†å‡½æ•°ã€‚
- è°ƒç”¨taskInfoTable.queryæ–¹æ³•ï¼Œä¼ å…¥GLOBAL_KEYå’Œtrueä½œä¸ºå‚æ•°ï¼Œä»¥åŠä¸€ä¸ªåŒ¿åå‡½æ•°ä½œä¸ºå›žè°ƒå‡½æ•°ã€‚
- åœ¨åŒ¿åå‡½æ•°ä¸­ï¼Œåˆ¤æ–­resæ˜¯å¦å­˜åœ¨ä¸”é•¿åº¦ä¸ä¸º0ï¼Œå¦‚æžœæ˜¯ï¼Œåˆ™è°ƒç”¨resolve(res)å°†ç»“æžœä¼ é€’ç»™Promiseå¯¹è±¡ï¼›å¦åˆ™ï¼Œæ‰“å°ä¸€æ¡è­¦å‘Šä¿¡æ¯ï¼Œå¹¶è°ƒç”¨resolve(res ?? [])å°†ç©ºæ•°ç»„ä¼ é€’ç»™Promiseå¯¹è±¡ã€‚
- è¿™æ ·ï¼Œå½“getAllTaskå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šè¿”å›žä¸€ä¸ªPromiseå¯¹è±¡ï¼Œè¯¥å¯¹è±¡åœ¨æŸ¥è¯¢æ•°æ®åº“åŽä¼šè¢«è§£å†³æˆ–æ‹’ç»ã€‚


å¥½çš„ï¼Œæˆ‘æ¥è¿›ä¸€æ­¥è®²è§£asyncå’Œpromiseã€‚

- asyncæ˜¯ä¸€ä¸ªå…³é”®å­—ï¼Œå®ƒå¯ä»¥æ”¾åœ¨ä¸€ä¸ªå‡½æ•°å®šä¹‰å‰é¢ï¼Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ˜¯å¼‚æ­¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¼šè¿”å›žä¸€ä¸ªpromiseå¯¹è±¡Â²âµã€‚
- promiseæ˜¯ä¸€ç§å¯¹è±¡ï¼Œå®ƒä»£è¡¨äº†ä¸€ä¸ªå¼‚æ­¥æ“ä½œçš„å½“å‰çŠ¶æ€ã€‚å¼‚æ­¥æ“ä½œå¯èƒ½è¿˜æ²¡æœ‰å®Œæˆï¼Œä½†promiseå¯¹è±¡æä¾›äº†ä¸€äº›æ–¹æ³•æ¥å¤„ç†æœ€ç»ˆçš„æˆåŠŸæˆ–å¤±è´¥â´ã€‚
- awaitæ˜¯ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œå®ƒå¯ä»¥æ”¾åœ¨ä¸€ä¸ªpromiseå¯¹è±¡å‰é¢ï¼Œè¡¨ç¤ºç­‰å¾…è¿™ä¸ªpromiseå¯¹è±¡è¢«è§£å†³æˆ–æ‹’ç»ã€‚å¦‚æžœpromiseå¯¹è±¡è¢«è§£å†³äº†ï¼Œawaitè¿ç®—ç¬¦ä¼šè¿”å›žè§£å†³å€¼ï¼›å¦‚æžœpromiseå¯¹è±¡è¢«æ‹’ç»äº†ï¼Œawaitè¿ç®—ç¬¦ä¼šæŠ›å‡ºé”™è¯¯Â²âµã€‚
- asyncå’Œawaitå¯ä»¥è®©æˆ‘ä»¬ç”¨åŒæ­¥çš„æ–¹å¼å†™å¼‚æ­¥çš„ä»£ç ï¼Œä½¿å¾—ä»£ç æ›´åŠ ç®€æ´å’Œæ¸…æ™°Â³ã€‚

è¿™ä¸ªå‡½æ•°æ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼šgetAllTask().then(res => { let deepCopyData = JSON.stringify(this.taskList); deepCopyData = JSON.parse(deepCopyData); this.taskList = taskIndexDataInit(deepCopyData, res); })åœ¨è¿™é‡Œé¢ï¼Œresæ˜¯getAllTask()ä¸­çš„ä»€ä¹ˆï¼Ÿ
åœ¨è¿™é‡Œé¢ï¼Œresæ˜¯getAllTask()ä¸­çš„resï¼Œä¹Ÿå°±æ˜¯taskInfoTable.queryæ–¹æ³•çš„å›žè°ƒå‡½æ•°çš„å‚æ•°ã€‚å®ƒè¡¨ç¤ºæ•°æ®åº“æŸ¥è¯¢çš„ç»“æžœï¼Œå¯èƒ½æ˜¯ä¸€ä¸ªæ•°ç»„æˆ–è€…nullã€‚
å¯æ˜¯åœ¨getAllTaskä¸­å®šä¹‰çš„è¿”å›žå€¼æ˜¯return new Promise((resolve) => {...}ï¼Œå¹¶ä¸æ˜¯reså•Š
æ˜¯çš„ï¼ŒgetAllTask()è¿”å›žçš„æ˜¯ä¸€ä¸ªpromiseå¯¹è±¡ï¼Œä½†æ˜¯è¿™ä¸ªpromiseå¯¹è±¡ä¼šåœ¨æ•°æ®åº“æŸ¥è¯¢å®ŒæˆåŽè¢«è§£å†³ï¼Œå¹¶ä¸”ä¼ é€’resä½œä¸ºè§£å†³å€¼ã€‚æ‰€ä»¥ï¼Œå½“æˆ‘ä»¬ç”¨.thenæ–¹æ³•æ¥å¤„ç†è¿™ä¸ªpromiseå¯¹è±¡æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥æ‹¿åˆ°resä½œä¸ºå‚æ•°ã€‚
* promiseå¯ä»¥ä¼ é€’ä»»ä½•å€¼ä½œä¸ºè§£å†³å€¼ï¼Œåªè¦åœ¨è°ƒç”¨resolveå‡½æ•°æ—¶ä¼ å…¥è¿™ä¸ªå€¼å°±å¯ä»¥äº†ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªè¿™æ ·çš„promiseï¼š

return new Promise((resolve) => { resolve(â€œHelloâ€); });

è¿™ä¸ªpromiseä¼šè¢«ç«‹å³è§£å†³ï¼Œå¹¶ä¸”ä¼ é€’"Hello"ä½œä¸ºè§£å†³å€¼ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨.thenæ–¹æ³•æ¥èŽ·å–è¿™ä¸ªå€¼ï¼š

.then(value => { console.log(value); // Hello });
* */
import { TaskInfoTable } from '../common/database/tables/TaskInfoTable';
import { Logger } from '../common/utils/log/Logger';
import TaskInfo, { oneWeek } from '../common/bean/TaskInfo';
import {
    EVERYDAY,
    GLOBAL_KEY,
    TODAY,
    DRINK_STEP,
    DRINK_MAX_RANGE,
    EAT_APPLE_RANGE,
    TIMES_100
} from '../common/constants/CommonConstants';
import { TaskMapById, ITaskItem } from '../model/TaskInitList';
import { padTo2Digits } from '../common/utils/Utils';
import http from '@ohos.net.http';

let httpRequest = http.createHttp();
let task1: TaskInfo = {
    "id": 0,
    "taskID": 1,
    "isOpen": true,
    "date": "",
    "targetValue": "7:00",
    "isAlarm": true,
    "startTime": "",
    "endTime": ";",
    "frequency": "",
    "isDone": false,
    "finValue": ""
}

const taskInfoTable = new TaskInfoTable();

export const taskOriginData: ITaskItem[] = Object.keys(TaskMapById).map(item => {
    return TaskMapById[item];
})

/**
 * resolve: è¡¨ç¤ºæˆåŠŸæ—¶çš„å¤„ç†å‡½æ•°
 * @description Get all task status
 * @return object[] Database query results
 */
export const getAllTask = async () => {
    return new Promise((resolve) => {
        taskInfoTable.query(GLOBAL_KEY, true, (res) => {
            if (res?.length === 0) {
                Logger.warn('queryTaskList', 'has no data!!');
                resolve(res ?? []);
            }
            resolve(res);
        })
    });
}

export const newGetAllTask = async () => {
    console.log('èŽ·å–å…¨éƒ¨ä»»åŠ¡');
    return new Promise((resolve) => {
        httpRequest.request("http://119.3.171.141:3000/task/getAll",
            {
                method: http.RequestMethod.GET,
            }, (err, data) => {
                if (!err) {
                    // data.resultä¸ºhttpå“åº”å†…å®¹ï¼Œå¯æ ¹æ®ä¸šåŠ¡éœ€è¦è¿›è¡Œè§£æž
                    console.info('Result:' + data.result);
                    console.info('code:' + data.responseCode);
                    // data.headerä¸ºhttpå“åº”å¤´ï¼Œå¯æ ¹æ®ä¸šåŠ¡éœ€è¦è¿›è¡Œè§£æž
                    console.info('header:' + JSON.stringify(data.header));
                    console.info('cookies:' + data.cookies); // 8+
                    resolve(data.result);
                } else {
                    console.info('error:' + JSON.stringify(err));
                    // è¯¥è¯·æ±‚ä¸å†ä½¿ç”¨ï¼Œè°ƒç”¨destroyæ–¹æ³•ä¸»åŠ¨é”€æ¯ã€‚
                    httpRequest.destroy();
                }
            }
        )
    });
}

export const newAddTask = (params: TaskInfo) => {
    if (!params) {
        Logger.error('addTask', 'params is null!');
        return;
    }
    return new Promise((resolve, reject) => {
        httpRequest.request("http://119.3.171.141:3000/task/add",
            {
                method: http.RequestMethod.POST,
                header: { 'Content-Type': 'application/json' },
                extraData: params,
            }, (err, data) => {
                if (!err) {
                    // data.resultä¸ºhttpå“åº”å†…å®¹ï¼Œå¯æ ¹æ®ä¸šåŠ¡éœ€è¦è¿›è¡Œè§£æž
                    console.info('Result:' + data.result);
                    console.info('code:' + data.responseCode);
                    // data.headerä¸ºhttpå“åº”å¤´ï¼Œå¯æ ¹æ®ä¸šåŠ¡éœ€è¦è¿›è¡Œè§£æž
                    console.info('header:' + JSON.stringify(data.header));
                    console.info('cookies:' + data.cookies); // 8+
                    resolve(data.result);
                } else {
                    console.info('error:' + JSON.stringify(err));
                    // è¯¥è¯·æ±‚ä¸å†ä½¿ç”¨ï¼Œè°ƒç”¨destroyæ–¹æ³•ä¸»åŠ¨é”€æ¯ã€‚
                    httpRequest.destroy();
                    reject(data.result);
                }
            }
        )
    })
}
/**
 * @param params:TaskInfo
 */
export const addTask = (params: TaskInfo) => {
    if (!params) {
        Logger.error('addTask', 'params is null!');
        return;
    }
    return new Promise((resolve, reject) => {
        taskInfoTable.updateDataByDate(params, (flag) => {
            if (!flag) {
                Logger.error('insertTaskSetting', 'updateTaskSetting Error!');
                reject(flag);
            }
            resolve(flag);
        })
        /*è¿™é‡Œå…¶å®žä¸åº”è¯¥å°†todayçš„ä»»åŠ¡çš„isDoneè®¾ç½®ä¸ºtrueï¼Œè¿™ä¹Ÿæ˜¯åŽŸç¨‹åºä¸­çš„ä¸€ä¸ªbugï¼šå»ºç«‹å¥½ä»»åŠ¡åŽï¼Œå›žåˆ°ä¸»é¡µé¢å´å‘çŽ°è¯¥ä»»åŠ¡å·²ç»å®Œæˆ*/
        /*taskInfoTable.updateDataByDate({ ...params, date: TODAY, isDone: true }, (flag) => {
            if (!flag) {
                Logger.error('insertTaskSetting', 'updateTaskSetting Error!');
                reject(flag);
            }
            resolve(flag);
        })*/
    })
}

/**
 * @description Used to initialize task list data from database data
 * @param taskInitList Task list initial data
 * @param taskInfoData Database query data
 */
export const taskIndexDataInit = (taskInitList, taskInfoData) => {
    const afterInitData = taskInitList.map((content) => {
        taskInfoData.forEach((item) => {
            if (item?.taskID === content?.taskID) {
                content.isOpen = item?.isOpen;
                content.targetValue = item?.targetValue;
                content.isAlarm = item?.isAlarm;
                content.startTime = item?.startTime;
                content.endTime = item?.endTime;
                content.frequency = item?.frequency;
            }
        });
        return content;
    });
    return afterInitData;
}

/**
 * @description format data as json string
 * @param params = {}
 */
export const formatParams = (params = {}) => {
    return JSON.stringify(params);
}

/**
 * @description Initialization frequency string
 * @param frequencyIdCollection
 * @return string Frequency string
 */
export const initFrequencyString = (frequencyIdCollection) => {
    if (frequencyIdCollection === '') {
        return EVERYDAY;
    }
    const frequencyIdArray = frequencyIdCollection.split(',').map(item => Number(item));
    const length = frequencyIdArray.length;
    if (length === 7) {
        return EVERYDAY;
    }
    const frequencyString = frequencyIdArray.reduce((pre, current) => {
        return pre + ' ' + oneWeek[current];
    }, '')
    return frequencyString;
}

/**
 * @description Returns the timestamp of today's selected time
 * @param currentTime
 * @return timestamp
 */
export const returnTimeStamp = (currentTime: string) => {
    const timeString = `${TODAY} ${currentTime}`;
    return new Date(timeString).getTime();
}

/**
 * @description It is used for formatting time and displayed in the form of HH: mm
 * @param value
 */
export const formatTime = (value: TimePickerResult) => {
    return `${padTo2Digits(value?.hour)}:${padTo2Digits(value?.minute)}`;
}

/**
 * @description Range of generated drinking water 0.25 - 5 L
 * @return Array<string>
 */
export const createDrinkRange = () => {
    const drinkRangeArr = []
    for (let i = DRINK_STEP; i <= DRINK_MAX_RANGE; i += DRINK_STEP) {
        drinkRangeArr.push(`${i / TIMES_100} L`);
    }
    return drinkRangeArr;
}

/**
 * @description Generate the range of eating apples 1 - 100
 * @return Array<string>
 */
export const createAppleRange = () => {
    const appleRangeArr = []
    for (let i = 1; i <= EAT_APPLE_RANGE; i++) {
        appleRangeArr.push(`${i} ä¸ª`);
    }
    return appleRangeArr;
}